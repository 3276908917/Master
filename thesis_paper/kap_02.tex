\chapter{CAMB, Initial Setup}

As mentioned in section~\ref{sec: boltzmann_intro}, this work will rely on
power spectra calculated by the Boltzmann solver CAMB. Although CAMB was
written in Fortran-90, we will be exclusively accessing CAMB through its
Python wrappers, as Cassandra-Linear is a Python package. In this chapter, we will explain our setup and introduce the reader to various CAMB settings.

\begin{comment}
\textcolor{blue}{
I hope to, in painstaking detail, cover many of the lines of the code that I
have written to interface with CAMB. I will include plots to indicate, at
every step, what incorrect settings cause the power spectrum to look like (or,
for subtler errors, what the error curves looked like compared to Ariel's
results, which I treated as a sort of ``ground truth''). This should also be a
good example to flex my physics interpretation skills: why does this incorrect
setting produce this undesired pattern?}

\textcolor{blue}{You might think that this is sort of an inappropriate 
section
for a master's thesis (especially since I have in mind that this be a lengthy 
section), but I would like to include it unless you feel very strongly. After
all, I spent several months of the project debugging at least ten different 
ways that slight and major errors in the various settings led to 
irreconcilable results.}
\end{comment}

\textcolor{orange}{Ariel recommends
just talking about the correct lines, don't talk about what happens when
they're wrong.}

%%% C'mon, Ariel's GOT to let me have this plot. It's a big open question!
\begin{comment}
In figure \ref{fig: spectrum_type}, we can see that requesting of the wrong
power spectrum type can in some low-$\omega_\nu$ cases yields errors so low
that we might accidentally overlook them. This error pattern is easily
recognizable and is a consequence of the definition of the power spectrum: the
Fourier transform  of the two-point correlation function. ...Okay, I'm still 
thinking about this. I don't understand %yet, but I'll be sure to ask you if I
%I'm still struggling about it.
\end{comment}
%%%

%s Now discuss individual settings

To set up a power spectrum calculation, CAMB requires a
\verb|CAMBparams| object which stores all the settings from accuracy levels
to cosmological parameter values. In the following sections, \verb|pars| 
refers to the \verb|CAMBparams| object within our code.

\section{Universal Settings}

First, we will motivate settings that are universal across runs. These are 
mostly 
contained in the helper function \verb|apply_universal_output_settings| in the 
Cassandra-Linear script, \verb|camb_interface.py|.

Although CAMB also offers CMB spectra, we are interested in the
matter power spectrum. Therefore, \verb|apply_universal_output_settings|  
first disables CMB calculations:

\verb|pars.WantCls = False| \quad CMB transfer function

\verb|pars.Want_CMB = False| \quad temperature and polarization spectra

\verb|pars.Accuracy.AccuratePolarization = False|

\verb|pars.DoLensing = False| \quad calculates lensing of the CMB

\verb|pars.WantScalars = False| \quad calculates E modes of CMB polarization, 
which are generated by density perturbations \cbib{Basu}.

\

Next, we need to specify that we want the \textit{linear} matter power 
spectrum:

\verb|pars.NonLinear = camb.model.NonLinear_none|

% Why is CAMB set up this way anyway? Why do I have to put in a model object 
% instead of simply flipping a Boolean? {probably not a relevant question for
% this thesis.}

\

The helium mass fraction $Y_\text{He}$ is not a focus of this work and is left
at the standard value:

\verb|pars.YHe = 0.24| \quad \cbib{Cooke}

\

Last, we set the accuracy with which CAMB should calculate power spectra.
Although higher accuracies should require greater computation time, we only
need to generate one training set in order to produce an emulator. Therefore,
computation time invested now will result in an emulator which is more
accurate and equally fast.

\verb|pars.Accuracy.AccuracyBoost = 3| \quad requests more multipoles in the Boltzmann hierarchy. \textcolor{orange}{Whatever that is}

\verb|pars.Accuracy.lAccuracyBoost = 3|

The second line is explained in the CAMB documentation only as a ``general 
accuracy setting effecting [\textit{sic}] everything related to step sizes 
etc''. \textcolor{orange}{But what, more specifically, does it do?}

\

A few additional universal settings are handled in the function
\verb|input_cosmology|, which translates a cosmology dictionary into 
the \verb|CAMBparams| object \verb|pars|. The cosmology dictionary is
intended to store cosmological parameters in a more user-friendly format.
All cosmology dictionaries should follow the same structure in order to be 
correctly interpreted by the various functions in Cassandra-Linear. The required keys are described in table~\ref{tab: cosmology_dictionary}; all
values should be floating point numbers. The user is advised to print out
cosmology dictionaries with the \verb|print_cosmology| function in the
\verb|user_interface.py| script, which will automatically ignore unused keys
and resolve extreme roundoff cases.

% Address unused (OmL) and sometimes used (OmK) parameters
% Remind the user that, to "leave values at default for cassL," he can
% simply copy model0 and modify that. Use the function default_cosmology()

\begin{table}[ht!]
\centering
\begin{tabular}{l|l}
\hline
Key & Significance \\ \hline
'ombh2' & $\omega_b$ \\
'omch2' & $\omega_c$ \\
'n\_s' & $n_s$ \\
'A\_s' & $A_s$ \\
'OmK' & $\Omega_K$ \\
'h' & $h$ \\
'w0' & $w_0$ in the CPL EoS for DE \\
'wa' & $w_a$ in the CPL EoS for DE \\
'sigma12' & $\sigma_{12}$\footnotemark \\
'omnuh2' & $\omega_\nu$ \\
'mnu' & $\sum_i m_{\nu, i}$ \\
'nnu\_massive' & Number of massive $\nu$ species \\ \hline
\end{tabular}
 \cprotect\caption[Cosmology Dictionary Keys]{Keys
 	expected by the functions in
 	the \verb|camb_interface.py| script. Keep in mind that any additional
 	keys that may appear when printing out a cosmology dictionary
 	(such as 'OmL') are generally not used and therefore may be inconsistent.
 	with other parameter values.}
 \label{tab: cosmology_dictionary}
\end{table}
 	
\footnotetext{Specifying a $\sigma_{12}$ value will not affect the power
spectrum returned by \verb|evaluate_cosmology|. Instead, this field is used
by the \verb|direct_eval_cell| and \verb|interpolate_cell| functions
(section~\ref{sec: generate_emu_data}).}

The \verb|input_cosmology| function implements the following additional
settings universal to all of our power spectra:

 not and optical depths $\tau$ to the CMB 
are not parameters of interest to us, and we keep these values fixed:
\textcolor{orange}{What kinds of parameters are these in evolution mapping?
Do they affect the power spectrum at all?}

\verb|tau=0.0952| \quad specified in the call to \verb|pars.set_cosmology|.
$\tau$ describes the optical depth to the CMB.

%s k range

\verb|pars.Transfer.kmax = 10.0 if hubble_units else 10.0 / h| \quad the smallest scale at which we evaluate the power spectrum.
\footnote{Technically, this is the smallest scale at which we evaluate the
\textit{transfer} function, but for our purposes the distinction is
unimportant. For an introduction to the transfer function, see \citet{FECS}.} 

CAMB expects \verb|kmax| in Hubble units, so we divide out the factor $h$ if 
the user wishes to use the recommended absolute units.
We note that our limit is extremely small. The smallest scale probed by
currently available cosmological data is $k \approx 3$ Mpc$^{-1}$
\cbib{Aghanim}.

\textcolor{orange}{We'll also want to justify why we're using k ranges out to
such tiny scales. It's true that our surveys can't probe these scales, but
this work is purely computational. In its application, the high k values can
always be disregarded.}


\section{Dark Energy Settings}

The \verb|input_dark_energy| function.

\section{Neutrino Settings}

%s Neutrino peculiarities

%For example, one parameter that tripped me up for a while:
The impact of some parameters can be quite subtle, especially (we imagine)
for users unfamiliar with the nuances of neutrino physics.

Consider the neutrino mass 
hierarchy: the options are degenerate, normal, and inverted. The CAMB 
documentation annotates this parameter as ``(1 or 2 eigenstate 
approximation),'' but this is somewhat unclear. Is the degenerate hierarchy 
the single mass eigenstate approximation? Do both normal and inverted 
hierarchies involve two eigenstates? Besides, even if this description were
literally accurate, why does use of the normal mass hierarchy lead to
incorrect results?

I think the weirdness is because we're always
insisting that \verb|nnu_massive_in=1|. Therefore,
if the hierarchy is not denerate, there will still
be a mass distribution, which means that the 
massive neutrino won't have all of the mass!

Beware the neutrino settings. The effective number of massive neutrinos is about 3.027

\

Other parameters not explicitly addressed here--including, of course, the
cosmological parameters of primary interest to this paper--may be assumed to 
have been left at default CAMB values.

\

%s MEMNeC manipulation functions

The \verb|omnuh2_to_mnu| function. Similarly, the \verb|mnu_to_omnuh2|
function. The \verb|balance_neutrinos_with_CDM| function.

%s other important nu stuff

The \verb|specify_neutrino_mass| function is \textit{not} a helper function!
It is important that the user call this on the target cosmology before passing
it to \verb|evaluate_cosmology|.

\section{Convenience Functions}

% camb\_interface.py

\textcolor{blue}{The purpose of this section is to anticipate the Python
package Cassandra-Linear. The settings we describe in the previous section
still technically correspond to lines of code of course, but here we tie these
individually-treated lines into bigger functions that users can quickly use to
get results from CAMB!}

%s Explain cosmologies.dat file

%s Explain our accessing of it

The \verb|parse_redshifts| function returns the redshifts associated with a
particular model in the order which CAMB would prefer

* CAMB prefers newest last
* The \verb|cosmologies.dat| file has some $z$ columns which allow for easy
evolution mapping comparisons. % Maybe this should go in the previous
% minisection
	
%s Pipeline functions

The \verb|get_CAMB_interpolator| function.

%s The crown jewels

The \verb|boltzmann_battery| function.

The \verb|evaluate_cosmology| function.

The \verb|cosmology_to_PK_interpolator| function.

\section{Verifying Our Settings}

%s Even more code

The \verb|load_benchmark| function.

%! This is weird, and perhaps inappropriate for a thesis document.

To test this setup, we compare our results with those of Ariel S\'{a}nchez 
(within the native Fortran framework of CAMB) and Andrea Pezzotta for the
first seven Aletheia cosmologies and four $\omega_\nu$ physical densities in
neutrinos (\textcolor{green}{approximately} 0, 0.0006, 0.002, 0.006.), for a 
total of 28
models. The errors are miniscule and recorded in figure XXY. After verifying
the accuracy of our code in this way, we proceed to experiment with the power
spectra in order to explore solutions to the evolution mapping problem.

% Aletheia Model 8 has not been integrated into our code suite yet. We can’t handle its DE weirdness. Instead of bringing up and then discarding model 8, we shouldn’t mention it at all.

