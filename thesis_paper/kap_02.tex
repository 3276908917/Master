\chapter{CAMB, Initial Setup}

As mentioned in section~\ref{sec: boltzmann_intro}, this work will rely on
power spectra calculated by the Boltzmann solver CAMB. Although CAMB was
written in Fortran-90, we will be exclusively accessing CAMB through its
Python wrappers, as Cassandra-Linear is a Python package. In this chapter, we will explain our setup and introduce the reader to various CAMB settings.

\section{Configuring CAMB for this Project}
\label{sec: camb_config}

\begin{comment}
\textcolor{blue}{
I hope to, in painstaking detail, cover many of the lines of the code that I
have written to interface with CAMB. I will include plots to indicate, at
every step, what incorrect settings cause the power spectrum to look like (or,
for subtler errors, what the error curves looked like compared to Ariel's
results, which I treated as a sort of ``ground truth''). This should also be a
good example to flex my physics interpretation skills: why does this incorrect
setting produce this undesired pattern?}

\textcolor{blue}{You might think that this is sort of an inappropriate 
section
for a master's thesis (especially since I have in mind that this be a lengthy 
section), but I would like to include it unless you feel very strongly. After
all, I spent several months of the project debugging at least ten different 
ways that slight and major errors in the various settings led to 
irreconcilable results.}
\end{comment}

\textcolor{orange}{Ariel recommends
just talking about the correct lines, don't talk about what happens when
they're wrong.}

%%% C'mon, Ariel's GOT to let me have this plot. It's a big open question!
\begin{comment}
In figure \ref{fig: spectrum_type}, we can see that requesting of the wrong
power spectrum type can in some low-$\omega_\nu$ cases yields errors so low
that we might accidentally overlook them. This error pattern is easily
recognizable and is a consequence of the definition of the power spectrum: the
Fourier transform  of the two-point correlation function. ...Okay, I'm still 
thinking about this. I don't understand %yet, but I'll be sure to ask you if I
%I'm still struggling about it.
\end{comment}
%%%

%s Now discuss individual settings

To set up a power spectrum calculation, CAMB requires a
\verb|CAMBparams| object which stores all of the settings from accuracy levels
to cosmological parameter values. In the following lines, \verb|pars| 
describes the \verb|CAMBparams| object that our code uses. First, we will
include lines that are universal across runs, which is contained in the
helper function \verb|apply_universal_output_settings| in the Cassandra-Linear
script, \verb|camb_interface.py|.

\

First of all, although CAMB also offers CMB spectra, we are interested in the
matter power spectrum. Therefore, we disable CMB calculations with the 
following lines:

\verb|pars.WantCls = False| \quad CMB transfer function

\verb|pars.Want_CMB = False| \quad temperature and polarization spectra

\verb|pars.DoLensing = False| \quad calculates lensing of the CMB

\verb|pars.WantScalars = False| \quad calculates E modes of CMB polarization, 
which are generated by density perturbations \cbib{Basu}

\

Next, we need to specify that we want the \textit{linear} matter power 
spectrum:

\verb|pars.NonLinear = camb.model.NonLinear_none|

% Why is CAMB set up this way anyway? Why do I have to put in a model object 
% instead of simply flipping a Boolean? {probably not a relevant question for
% this thesis.}

\

The helium mass fraction $Y_\text{He}$ and optical depths $\tau$ to the CMB 
are not parameters of interest to us, and we keep these values fixed:
\textcolor{orange}{What kinds of parameters are these in evolution mapping?
Do they affect the power spectrum at all?}

\verb|pars.YHe = 0.24|

While \verb|tau=0.0952| is specified in the call to \verb|pars.set_cosmology|.

\

\verb|pars.Transfer.kmax = 10.0 if hubble_units else 10.0 / h|

%s k range

\textcolor{orange}{We'll also want to justify why we're using k ranges out to
such tiny scales. It's true that our surveys can't probe these scales, but
this work is purely computational. In its application, the high k values can
always be disregarded.}

\

%s Neutrino peculiarities

%For example, one parameter that tripped me up for a while:
The impact of some parameters can be quite subtle, especially (we imagine)
for users unfamiliar with the nuances of neutrino physics.

Consider the neutrino mass 
hierarchy: the options are degenerate, normal, and inverted. The CAMB 
documentation annotates this parameter as ``(1 or 2 eigenstate 
approximation),'' but this is somewhat unclear. Is the degenerate hierarchy 
the single mass eigenstate approximation? Do both normal and inverted 
hierarchies involve two eigenstates? Besides, even if this description were
literally accurate, why does use of the normal mass hierarchy lead to
incorrect results?

Beware the neutrino settings. The effective number of massive neutrinos is about 3.027

\

In principle, the accuracy boost should increase the variance in our models but should not affect the bias. The line is

\verb|pars.Accuracy.AccuracyBoost = 3|

\textcolor{orange}{But what does it do? The CLASS citation may have some
useful information!}

\verb|pars.Accuracy.lAccuracyBoost = 3|

\verb|pars.Accuracy.AccuratePolarization = False|

\

Other parameters not explicitly addressed here--including, of course, the
cosmological parameters of primary interest to this paper--may be assumed to 
have been left at default CAMB values.

\section{Convenience Functions}

% camb\_interface.py

\textcolor{blue}{The purpose of this section is to anticipate the Python
package Cassandra-Linear. The settings we describe in the previous section
still technically correspond to lines of code of course, but here we tie these
individually-treated lines into bigger functions that users can quickly use to
get results from CAMB!}

%s Explain cosmologies.dat file

%s Explain our accessing of it

The \verb|parse_redshifts| function returns the redshifts associated with a
particular model in the order which CAMB would prefer

* CAMB prefers newest last
* The \verb|cosmologies.dat| file has some $z$ columns which allow for easy
evolution mapping comparisons. % Maybe this should go in the previous
% minisection
	
%s MEMNeC manipulation functions

The \verb|omnuh2_to_mnu| function. Similarly, the \verb|mnu_to_omnuh2|
function. The \verb|balance_neutrinos_with_CDM| function.

%s Pipeline functions

The \verb|apply_universal_output_settings| function modifies the \verb|pars|
object according to the settings described in section~\ref{sec: camb_config}.

The \verb|input_dark_energy| function.

The \verb|specify_neutrino_mass| function is \textit{not} a helper function!
It is important that the user call this on the target cosmology before passing
it to \verb|evaluate_cosmology|.

The \verb|get_CAMB_interpolator| function.

%s The crown jewels

The \verb|boltzmann_battery| function.

The \verb|evaluate_cosmology| function.

The \verb|cosmology_to_PK_interpolator| function.

\section{Verifying Our Settings}

%s Even more code

The \verb|load_benchmark| function.

%! This is weird, and perhaps inappropriate for a thesis document.

To test this setup, we compare our results with those of Ariel S\'{a}nchez 
(within the native Fortran framework of CAMB) and Andrea Pezzotta for the
first seven Aletheia cosmologies and four $\omega_\nu$ physical densities in
neutrinos (\textcolor{green}{approximately} 0, 0.0006, 0.002, 0.006.), for a 
total of 28
models. The errors are miniscule and recorded in figure XXY. After verifying
the accuracy of our code in this way, we proceed to experiment with the power
spectra in order to explore solutions to the evolution mapping problem.

% Aletheia Model 8 has not been integrated into our code suite yet. We can’t handle its DE weirdness. Instead of bringing up and then discarding model 8, we shouldn’t mention it at all.

